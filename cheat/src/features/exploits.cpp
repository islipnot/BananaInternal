#include "pch.hpp"
#include "cfg.hpp"
#include "sdk/interfaces.hpp"
#include "core/hooks/hooks.hpp"
#include "features.hpp"
#include "core/gui/gui.hpp"

struct weapon_state_t
{
	template <typename t> struct field
	{
		t value;
		bool modified = false;

		__forceinline void set(t new_value)
		{
			this->value = new_value;
			this->modified = true;
		}
	};

	struct spread_info
	{
		float normal;
		float running;
	};

	int index = 0;
	field<glm::vec3>   recoil = {};
	field<spread_info> spread = {};
};

namespace features::exploits
{
	void run()
	{
		const std::lock_guard guard(sdk::internal::player_mutex);

		// Getting local player

		const auto local_player = sdk::main::player_data->local_player();
		if (!local_player) return;

		const auto movement = local_player->player_movement;
		if (!movement) return;

		// No-clip

		if ((reinterpret_cast<void*>(movement->fields.noClipMovement) == movement->fields.JOGBMBDCNAL) != cfg::exploits::noclip)
		{
			sdk::fn::toggle_noclip(movement, nullptr);
		}

		// Auto shoot

		if (cfg::exploits::auto_shoot && !local_player->is_dead)
		{
			const auto wpn_mgr = sdk::main::weapon_mgr->instance;

			if (wpn_mgr)
			{
				const auto wpn = wpn_mgr->fields.current_weapon;

				if (wpn && features::aimbot::get_target(nullptr, nullptr, nullptr))
				{
					features::exploits::hkDoAttack(wpn, nullptr);
				}
			}
		}
	}

	void hkDoAttack(il2cpp::Weapon_Firearms_o* _this, const il2cpp::MethodInfo* method)
	{
		// Magic bullet & silent aim
		
		glm::vec3 og_cam_pos;
		glm::vec4 og_cam_rot;
		bool restore_cam    = false;
		bool restore_angles = false;

		if (cfg::exploits::magic_bullet || (cfg::aimbot::enabled && cfg::aimbot::silent_aim))
		{
			sdk::transform_t* bone_transform  = nullptr;
			const sdk::ClientFields_t* target = features::aimbot::get_target(nullptr, nullptr, &bone_transform);

			if (target)
			{
				sdk::main::main_cam->get_rot(&og_cam_rot);
				
				if (cfg::exploits::magic_bullet)
				{	
					glm::vec3 jaw_pos;
					sdk::transform_t* jaw_transform;

					if (target->get_bone(hash("Jaw"), &jaw_pos, &jaw_transform))
					{
						sdk::main::main_cam->get_pos(&og_cam_pos);

						glm::vec3 jaw_forward;
						sdk::fn::transform_rotate(jaw_transform, 30.0f, 0.0f, 0.0f, nullptr);
						sdk::fn::transform_get_forward(&jaw_forward, jaw_transform, nullptr);

						jaw_pos += jaw_forward * 2.0f; // too close to the head and it can blank. also important not to invert the forward, sometimes only behind the head counts as headshot. great hitboxes!

						sdk::main::main_cam->set_pos(&jaw_pos);
						sdk::fn::transform_look_at(sdk::main::main_cam->cam_transform, jaw_transform, nullptr);

						gui::aim_targ = jaw_transform;
						restore_cam = true;
					}
				}
				else if (bone_transform)
				{
					sdk::fn::transform_look_at(sdk::main::main_cam->cam_transform, bone_transform, nullptr);
					gui::aim_targ  = bone_transform;
					restore_angles = true;
				}
			}
		}

		static std::unordered_map<void*, weapon_state_t> state;
		auto& cur_state = state[_this];
		auto& fields = _this->fields;

		// No recoil

		{
			auto& recoil_state = cur_state.recoil;

			float& x = fields.recoilX;
			float& y = fields.recoilY;
			float& z = fields.recoilZ;

			if (cfg::exploits::no_recoil)
			{
				if (!recoil_state.modified)
				{
					recoil_state.set({ x, y, z });

					x = 0.0f;
					y = 0.0f;
					z = 0.0f;
				}
			}
			else if (state[_this].recoil.modified)
			{
				x = recoil_state.value.x;
				y = recoil_state.value.y;
				z = recoil_state.value.z;

				recoil_state.modified = false;
			}
		}

		// No spread

		{
			auto& spread = cur_state.spread;

			float& normal  = fields.normalSpread;
			float& running = fields.runSpread;

			if (cfg::exploits::no_spread)
			{
				if (!spread.modified)
				{
					spread.set({ normal, running });

					normal  = 0.0f;
					running = 0.0f;
				}
			}
			else if (spread.modified)
			{
				normal  = spread.value.normal;
				running = spread.value.running;

				spread.modified = false;
			}
		}

		// Cleanup

		hooks::oDoAttack(_this, method);

		if (restore_cam)
		{
			sdk::fn::transform_set_pos_and_rot(sdk::main::main_cam->cam_transform, &og_cam_pos, &og_cam_rot, nullptr);
		}
		else if (restore_angles)
		{
			sdk::main::main_cam->set_rot(&og_cam_rot);
		}
	}

	void hkDoReload(il2cpp::Weapon_Firearms_o* _this, int used_ammo, bool send_to_server, const il2cpp::MethodInfo* method)
	{
		if (cfg::exploits::quick_reload)
		{
			sdk::fn::get_weapon(sdk::main::player_data->instance, nullptr);
		}
		else
		{
			hooks::oDoReload(_this, used_ammo, send_to_server, method);
		}
	}

	void hkDoJump(il2cpp::Movement_Movement_o* _this, void* callback, const il2cpp::MethodInfo* method)
	{
		if (cfg::exploits::inf_jump)
		{
			++_this->fields.player_movement->fields.jumpLeft;
		}

		static float jump_force = _this->fields.jumpForce;
		_this->fields.jumpForce = jump_force * cfg::exploits::jump_mult;

		hooks::oDoJump(_this, callback, method);
	}
}